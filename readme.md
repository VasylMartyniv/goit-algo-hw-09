### Порівняння алгоритмів

1) Часова складність:

- Жадібний алгоритм find_coins_greedy має часову складність O(n), де n — кількість номіналів монет. Це обумовлено тим,
  що
  він ітерується по списку монет, поки не знайде оптимальні номінали.
- Алгоритм динамічного програмування find_min_coins має часову складність O(m * n), де m — сума, яку потрібно видати, а
  n — кількість номіналів монет. Він обчислює мінімальну кількість монет для кожної проміжної суми.

2) Продуктивність на великих сумах:

- Жадібний алгоритм виконується швидко, але не завжди гарантує мінімальну кількість монет. Для великих сум він працює
  ефективно лише в тих випадках, коли набір монет відповідає вимогам жадібного підходу.
- Алгоритм динамічного програмування завжди знаходить оптимальне рішення, але його продуктивність знижується зі
  збільшенням суми через збільшення кількості проміжних обчислень. Він підходить для систем, де жадібний підхід не
  гарантує оптимальності.

### Висновок

Жадібний алгоритм є ефективним для систем монет, де кожен більший номінал є кратним меншому. Однак, для складніших
наборів монет, де жадібний алгоритм не завжди забезпечує оптимальний результат, алгоритм динамічного програмування є
кращим варіантом. Вибір між ними залежить від вимог конкретної задачі та набору монет, які використовуються в системі.